{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurrences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./matchesonscrollbar\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  };\n  function State(options) {\n    this.options = {};\n    for (var name in defaults) this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name];\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function (cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus);\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true;\n        highlightMatches(cm);\n      } else {\n        cm.on(\"focus\", onFocus);\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state);\n  }\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter;\n    if (!state.active) {\n      state.active = true;\n      scheduleHighlight(cm, state);\n    }\n  }\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      highlightMatches(cm);\n    }, state.options.delay);\n  }\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp((/\\w/.test(query.charAt(0)) ? \"\\\\b\" : \"\") + query.replace(/[\\\\\\[.+*?(){|^$]/g, \"\\\\$&\") + (/\\w/.test(query.charAt(query.length - 1)) ? \"\\\\b\" : \"\")) : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false, {\n        className: \"CodeMirror-selection-highlight-scrollbar\"\n      });\n    }\n  }\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n  function highlightMatches(cm) {\n    cm.operation(function () {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(),\n          line = cm.getLine(cur.line),\n          start = cur.ch,\n          end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end) addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"),\n        to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to);\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\");\n      if (selection.length >= state.options.minChars) addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n      if (from.ch > 0) {\n        var pos = {\n          line: from.line,\n          ch: from.ch - 1\n        };\n        var chr = cm.getRange(pos, from);\n        if (chr.match(/\\W/) === null) return false;\n      }\n      if (to.ch < cm.getLine(from.line).length) {\n        var pos = {\n          line: to.line,\n          ch: to.ch + 1\n        };\n        var chr = cm.getRange(to, pos);\n        if (chr.match(/\\W/) === null) return false;\n      }\n      return true;\n    } else return false;\n  }\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) && (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n  function makeOverlay(query, hasBoundary, style) {\n    return {\n      token: function (stream) {\n        if (stream.match(query) && (!hasBoundary || boundariesAround(stream, hasBoundary))) return style;\n        stream.next();\n        stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n      }\n    };\n  }\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defaults","style","minChars","delay","wordsOnly","annotateScrollbar","showToken","trim","State","options","name","hasOwnProperty","overlay","timeout","matchesonscroll","active","defineOption","cm","val","old","Init","removeOverlay","clearTimeout","state","matchHighlighter","off","cursorActivity","onFocus","hasFocus","highlightMatches","on","scheduleHighlight","setTimeout","addOverlay","query","hasBoundary","makeOverlay","showMatchesOnScrollbar","searchFor","RegExp","test","charAt","replace","length","className","clear","operation","somethingSelected","re","cur","getCursor","line","getLine","start","ch","end","slice","from","to","isWord","selection","getRange","str","match","pos","chr","boundariesAround","stream","string","token","next","skipTo","skipToEnd"],"sources":["D:/桌面/FYP/本地git仓库/react-sidebar-v1/node_modules/codemirror/addon/search/match-highlighter.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurrences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./matchesonscrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp((/\\w/.test(query.charAt(0)) ? \"\\\\b\" : \"\") +\n                                               query.replace(/[\\\\\\[.+*?(){|^$]/g, \"\\\\$&\") +\n                                               (/\\w/.test(query.charAt(query.length - 1)) ? \"\\\\b\" : \"\")) : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}